# ZAAI Core Domain Benchmarks
#
# This file defines the core benchmarks for the ZAAI system, covering fundamental
# programming tasks, API integrations, and application development scenarios.
# These benchmarks test basic competencies that form the foundation for more
# complex domain-specific tasks.
#
# Benchmark Categories:
# - Basic Output: Simple console output tasks (Hello World)
# - News: News API integration and data retrieval
# - API Integration: External API consumption (GitHub, OpenWeatherMap)
# - Game Development: Interactive application development (Pygame, OpenGL)
# - Email Service: Email sending and automation
# - Multi-file Projects: Code organization and module management
# - SMS Service: Text messaging integration
# - ITSM Service: IT Service Management system integration
#
# Cross-file Dependencies:
# - Inherits common configurations from ../suite.yaml
# - References workspace files (e.g., foobar.py) for multi-file benchmarks
# - Test functions import from main.py, game.py, headlines.py, etc.
#
# Execution Model:
# Each benchmark defines specs (requirements), tests (validation functions),
# references (external resources), and configs (parameters). The zerg_state
# parameter provides runtime context including configuration values and 
# benchmark metadata to test functions.

# Hello World Benchmark
# 
# The foundational benchmark that tests basic program execution and output.
# This benchmark validates that the AI can create a working program that
# produces the expected console output without errors.
- name: "hello"
  category: "Basic Output"
  description: |
    Create a simple program that prints 'Hello World' to the console. The program 
    should execute without errors and output exactly the expected greeting

  specs:
    - description: "Program prints the correct greeting"
      preconditions: "No strict preconditions"
      postconditions: "The program prints exactly 'Hello World' to standard output."
  
  tests:
    - description: "Hello World Output Test"
      preconditions: "A valid Hello World program file exists"
      postconditions: "The program prints 'Hello World' and exits successfully"
      entry_point: "test_hello_world"
      function_to_run: !python/function |
        def test_hello_world(zerg_state=None):
            """Test that the Hello World program prints the expected greeting; Expects a hello_world function in main.py"""
            print("Executing Hello World program")
              
            # NOTE: for testing
            # print(f"loaded zerg state: {zerg_state}")

            from main import hello_world

            result = hello_world()
            assert result == "Hello World", f"Expected 'Hello World', got '{output}'"

            return True

  references: []
  configs: []
# !Hello World


# Google Headlines Benchmark
#
# Tests API integration capabilities by retrieving news headlines from Google News.
# This benchmark validates the AI's ability to work with external APIs, handle
# HTTP requests, parse responses, and implement error handling and retry logic.
- name: "headlines"
  category: "News"
  description: "Create an API integration to retrieve the top headlines from Google News. The connector should be able to fetch the single top headline and then the top 10 headlines without using an API key."

  specs:
    - description: "Connector retrieves the top headline from Google News"
      preconditions: "A valid endpoint configuration."
      postconditions: "The connector successfully retrieves a non-empty top headline."
    - description: "Connector retrieves the top 10 headlines from Google News"
      preconditions: "A valid endpoint configuration for the news service."
      postconditions: "The connector successfully retrieves exactly 10 headlines as a list."
    - description: "Connector handles API errors and network timeouts"
      preconditions: "Simulated network failure or invalid configuration."
      postconditions: "The connector logs errors and retries the request if necessary."

  tests:
    - description: "Retrieve Top Headline"
      preconditions: "A valid endpoint configuration."
      postconditions: "Connector returns a valid headline as a string."
      function_to_run: !python/function |
        def test_get_top_headline(zerg_state=None):
            """Test retrieving the top headline from Google News."""
            print("Retrieving top headline from Google News")
            
            # Instantiate the connector (adjust instantiation as required)
  
            from headlines import GoogleHeadlinesConnector
            connector = GoogleHeadlinesConnector()
            headline = connector.get_top_headline()
            assert isinstance(headline, str), "Top headline is not a string"
            assert len(headline) > 0, "No headline retrieved"

            return True

    - description: "Retrieve Top 10 Headlines"
      preconditions: "A valid endpoint configuration."
      postconditions: "Connector returns a list of 10 headlines."
      function_to_run: !python/function |
        def test_get_top_10_headlines(zerg_state=None):
            """Test retrieving the top 10 headlines from Google News."""
            print("Retrieving top 10 headlines from Google News")

            # Attempt to import the GoogleHeadlinesConnector object.
            from headlines import GoogleHeadlinesConnector
    
            connector = GoogleHeadlinesConnector()
            headlines = connector.get_top_headlines(count=10)
            assert isinstance(headlines, list), "Headlines response is not a list"
            assert len(headlines) == 10, "Did not retrieve exactly 10 headlines"

            for headline in headlines:
                assert isinstance(headline, str) and len(headline) > 0, "Invalid headline in list"

            return True

    - description: "Handle API Errors and Network Timeouts"
      preconditions: "Simulated network error or invalid configuration."
      postconditions: "Connector gracefully handles errors and logs appropriate messages."
      function_to_run: !python/function |
        def test_handle_api_errors(zerg_state=None):
            """Test error handling for API errors in the Google Headlines connector."""
            print("Testing error handling for Google Headlines connector")

            # Attempt to import the GoogleHeadlinesConnector object.
            from headlines import GoogleHeadlinesConnector

            connector = GoogleHeadlinesConnector()

            # Simulate an error by setting an unrealistic timeout
            original_timeout = connector.config.get('timeout', 10)
            connector.config['timeout'] = 0.001
            response = connector.get_top_headline()
                
            # Expect a failure response or an exception
            assert response is None or "error" in str(response).lower(), "Error handling did not trigger"

            connector.config['timeout'] = original_timeout

            return True

  references: []
  configs:
    - name: "country"
      description: "Country code for filtering headlines (e.g., 'us')"
      value: "us"
# !Google Headlines


# GitHub Top Repositories Benchmark
#
# Tests GitHub API integration and JSON data processing capabilities.
# Validates the AI's ability to authenticate with APIs, make HTTP requests,
# handle pagination, and process structured JSON responses.
- name: "github"
  category: "API Integration"
  description: "Create an API integration that retrieves the top 10 GitHub repositories by star count. The connector should run code that repeatedly fixes issues until it works, then outputs the repositories."

  specs:
    - description: "Connector retrieves the top 10 GitHub repositories"
      preconditions: "A valid network connection and no API rate limits."
      postconditions: "The connector returns exactly 10 repositories with valid data (name, star count, and URL)."
    - description: "Connector handles API errors gracefully"
      preconditions: "Simulated API error (for example, using an invalid API token)."
      postconditions: "The connector logs errors and either returns fallback data or an error message."
    - description: "Connector implements retry logic on failed requests"
      preconditions: "A simulated API failure condition."
      postconditions: "The connector retries failed API calls up to the maximum configured retries."

  tests:
    - description: "Retrieve Top 10 GitHub Repositories"
      preconditions: "A valid API connection to GitHub."
      postconditions: "The connector returns a list of 10 repositories with keys 'name', 'stars', and 'url'."
      function_to_run: !python/function |
        def test_get_top_repositories(zerg_state=None):
            """Test retrieving the top 10 GitHub repositories."""
            print("Fetching top 10 GitHub repositories")

            # Attempt to import the GitHubConnector object.
            from main import GitHubConnector

            connector = GitHubConnector()
            repos = connector.get_top_repositories(count=10)
            assert isinstance(repos, list), "Response is not a list"
            assert len(repos) == 10, "Did not retrieve exactly 10 repositories"

            for repo in repos:
                assert isinstance(repo, dict), "Repository data is not a dictionary"
                assert "name" in repo, "Missing repository name"
                assert "stars" in repo, "Missing repository star count"
                assert "url" in repo, "Missing repository URL"

            print("Retrieved repositories:", repos)

            return True

  references: []

  configs:
    - name: "endpoint"
      description: "GitHub API endpoint for repository search"
      value: "https://api.github.com/search/repositories"
# !GitHub Top Repositories

# OpenWeatherMap Documentation Navigator Benchmark
#
# Tests web scraping, HTML parsing, and API documentation analysis capabilities.
# Validates the AI's ability to navigate web content, extract structured information,
# and answer queries about API requirements.
- name: "openweathermap"
  category: "API Documentation / Web Scraping"
  description: |
    Create a connector that uses the workspace to load and understand the OpenWeatherMap API 
    documentation by scraping and navigating the web. The connector should extract API endpoints 
    and answer queries about required parameters

  specs:
    - description: "Connector is able to load the OpenWeatherMap API documentation page"
      preconditions: "No strict preconditions"
      postconditions: "Connector retrieves the HTML content of the OpenWeatherMap API documentation page"
    - description: "Connector parses the API endpoints from the documentation"
      preconditions: "The documentation page is loaded"
      postconditions: "Connector extracts a list of API endpoints along with their descriptions"
    - description: "Connector answers queries about required parameters for a specific endpoint"
      preconditions: "API documentation is successfully parsed"
      postconditions: "Connector returns correct required parameters for a given endpoint (e.g., 'Current Weather Data')"

  tests:
    - description: "Load OpenWeatherMap API Documentation"
      preconditions: "Internet access is available"
      postconditions: "Connector successfully retrieves HTML content from the OpenWeatherMap API docs page"
      function_to_run: !python/function |
        def test_load_doc(zerg_state=None):
            """Test that the connector can load the OpenWeatherMap API documentation page."""
            print("Loading OpenWeatherMap API documentation")

            # Attempt to import the OpenWeatherMapConnector object.
            from main import OpenWeatherMapConnector

            connector = OpenWeatherMapConnector()
            content = connector.load_documentation()
            assert isinstance(content, str) and len(content) > 100, "Documentation content is too short or invalid"

            return True

    - description: "Parse API Endpoints from Documentation"
      preconditions: "Documentation content is loaded"
      postconditions: "Connector extracts a non-empty list of API endpoints with descriptions"
      function_to_run: !python/function |
        def test_parse_endpoints(zerg_state=None):
            """Test parsing of API endpoints from the documentation."""
            print("Parsing API endpoints from documentation")

            # Attempt to import the OpenWeatherMapConnector object.
            from main import OpenWeatherMapConnector

            connector = OpenWeatherMapConnector()
            
            endpoints = connector.parse_endpoints()

            assert isinstance(endpoints, list), "Parsed endpoints should be a list"
            assert len(endpoints) > 0, "No endpoints were parsed"
            for ep in endpoints:
                assert "endpoint" in ep and "description" in ep, "Each endpoint should include 'endpoint' and 'description'"

            return True

    - description: "Answer Query about Endpoint Parameters"
      preconditions: "API endpoints are parsed"
      postconditions: "Connector correctly returns required parameters for a specified endpoint"
      function_to_run: !python/function |
        def test_endpoint_parameters(zerg_state=None):
            """Test that the connector can answer queries about required parameters for an API endpoint."""
            print("Querying required parameters for 'Current Weather Data' endpoint")

            # Attempt to import the OpenWeatherMapConnector object.
            from main import OpenWeatherMapConnector

            connector = OpenWeatherMapConnector()
            params = connector.get_required_parameters(endpoint="Current Weather Data")
            assert isinstance(params, list), "Parameters should be returned as a list"

            # Expect 'appid' to be a required parameter for OpenWeatherMap API endpoints
            assert "appid" in params, "Required parameter 'appid' not found in endpoint parameters"

            return True

  references: []
  
  configs:
    - name: "documentation_url"
      description: "The URL of the OpenWeatherMap API documentation page"
      value: "https://openweathermap.org/api"
    
# !OpenWeatherMap Documentation Navigator

# Pygame 2D Game Development Benchmark
#
# Tests game development capabilities including graphics rendering, event handling,
# game loop implementation, and collision detection. Validates the AI's ability
# to create interactive applications with real-time user input.
- name: "pygame"
  category: "Game Development"
  description: |
    Build a simple one-file Pygame game that runs. Ensure required packages (e.g., pygame) are 
    installed and the game can open a window, run a game loop, and handle quit events

  specs:
    - description: "Game file is syntactically correct and executable"
      preconditions: "The game file exists at the specified path"
      postconditions: "The game file runs without syntax errors"

    - description: "Game opens a Pygame window and starts a game loop"
      preconditions: "Pygame is installed and the game file is executed"
      postconditions: "The Pygame window opens and the game loop runs without crashing"

    - description: "Game processes basic events and user input correctly"
      preconditions: "Game window is open and the event loop is running"
      postconditions: "The game processes events, such as user input, or exit signals to quit correctly"

    - description: "Game includes content per the designated game description and synopsis"
      preconditions: "Complete game implementation"
      postconditions: |
        Game includes content per the required genre, description and synopsis 
        including all relevant game play mechanics as pre required;

    - description: "Game runs inside the designated environment"
      preconditions: "Environment is prepared and required packages are installed"
      postconditions: "The game executes successfully within the environment"

    - description: "Required packages are installed and used"
      preconditions: "Access to pip or container management is available"
      postconditions: "The required packages are installed and imported and used successfully by the game"

  tests:
    - description: "Validate Game File Execution"
      preconditions: "The game implementation exists"
      postconditions: "The game executes without syntax errors and exits correctly per usage"
      function_to_run: !python/function |
        def test_game_execution(zerg_state=None):
            """Test that the Pygame game file executes without syntax errors."""
            print("Executing the Pygame game file...")

            # Attempt to import the Game object.
            from game import Game

            game = Game()
            exit_code = game.run()
            assert exit_code == 0, f"Game execution failed with return code {exit_code}"

            return True

  references: []

  configs:
    - name: "genre"
      description: "The kind of game to create"
      value: "simple flappy bird clone"
    - name: "game description and synopsis"
      description: "The description and synopsis of the game"
      value: |
        A simple flappy bird game clone where the user hits the spacebar to 'flap' the bird up
        and letting gravity pull the burd down.  The bird needs to dodge through increasingly small
        passages which scroll at the bird at increasing speed.  If the bird doesn't make it through
        the passage (collides with the wall or obstacle) the game is over, if the bird passes through
        then the player gets a point
    - name: "auto exit time"
      description: "The amount of time in seconds to run the game before auto exit so tests do not hang"
      value: 10  # constants.GAME_AUTO_EXIT_TIMEOUT_SECONDS from suite.yaml
# !Pygame Game 2d

# 3D First Person Shooter Benchmark
#
# Advanced game development benchmark testing 3D graphics programming with OpenGL.
# Validates complex graphics programming, 3D math, physics simulation, and
# real-time rendering capabilities. Currently marked as non-working.
# TODO: this is not working
- name: "3d_fps"
  category: "Game Development"
  description: |
    Build a simple one-file python 3d first person shooter game that runs. Ensure required packages are 
    installed and the game can open a window, run a game loop, and handle quit events;

  specs:
    - description: "Game file is syntactically correct and executable"
      preconditions: "The game file exists at the specified path"
      postconditions: "The game file runs without syntax errors"

    - description: "Game opens a game window and starts a game loop"
      preconditions: "Complete game implementation"
      postconditions: "The Pygame window opens and the game loop runs without crashing"

    - description: "Game processes basic events and user input correctly"
      preconditions: "Game window is open and the event loop is running"
      postconditions: "The game processes events, such as user input, or exit signals to quit correctly"

    - description: "Game is a 3D first person shooter"
      preconditions: "Complete game implementation"
      postconditions: |
        The game is a 3D first person shooter game in it's implementaiton and renders a 3d environment
        that the user is able to navigate with the WASD keys and mouse to look around;
        Note, the correct framework/engine needs to be used per this spec - this spec should 
        fail if the game is implemented in pseudo-3D and is actually 2D

    - description: "Game includes content per the designated game description and synopsis"
      preconditions: "Complete game implementation"
      postconditions: |
        Game includes content per the required genre, description and synopsis 
        including all relevant game play mechanics as pre required;

    - description: "Game runs inside the designated environment"
      preconditions: "Environment is prepared and required packages are installed"
      postconditions: "The game executes successfully within the environment"

    - description: "Required packages are installed and used - using pygame and pyopengl"
      preconditions: "Access to pip or container management is available"
      postconditions: "The required packages are installed and imported and used successfully by the game, pygame and pyopengl"

  tests:
    - description: "Validate Game File Execution"
      preconditions: "The game implementation exists"
      postconditions: "The game executes without syntax errors and exits correctly per usage"
      function_to_run: !python/function |
        def test_game_execution(zerg_state=None):
            """Test that the game runs without syntax errors."""
            print("running the game ...")
            
            game = Game()
            exit_code = game.run()
            assert exit_code == 0, f"Game execution failed with return code {exit_code}"

            return True

  references: []

  configs:
    - name: "genre"
      description: "The kind of game to create"
      value: "simple first person shooter"
    - name: "game description and synopsis"
      description: "The description and synopsis of the game"
      value: |
        A simple 3D first person shooter laser tag game where the player navigates with the WASD keys and 
        looks around using the mouse.  Include AI bots that spawn that can be shot (they go away when shot), and periodically 
        shoot at the player. Player gets a point for every bot they shoot, and every time a bot shoots 
        them they lose 5 health from a total of 100, and when they get to zero the game is over.  Include a simple city scape 
        to explore for the game so there are places to hide behind;
        Game uses pygame and pyopengl
    - name: "auto exit time"
      description: "The amount of time in seconds to run the game before auto exit so tests do not hang"
      value: 10  # constants.GAME_AUTO_EXIT_TIMEOUT_SECONDS from suite.yaml
# !3D FPS

# SendGrid Email Service Integration Benchmark
#
# Tests email service integration, API authentication, and message composition.
# Validates the AI's ability to integrate with third-party services, handle
# API keys securely, and compose structured email content.
- name: "sendgrid"
  category: "Email Service"
  description: |
    Create a connector that uses the SendGrid API to send emails. 
    The connector must save the SendGrid API key and sender email, and provide functionality to send emails.

  specs:
    - description: "Connector stores SendGrid API key and sender email"
      preconditions: "The system state has not yet been configured for SendGrid."
      postconditions: "The connector successfully saves the SendGrid API key and sender email to state."

    - description: "Connector sends an email to idanbeck@gmail.com"
      preconditions: "SendGrid is configured with a valid API key and sender email."
      postconditions: "The connector sends an email to idanbeck@gmail.com."

    - description: "Connector sends an email including the top 10 Google News headlines"
      preconditions: "SendGrid is configured and the connector can fetch Google News headlines."
      postconditions: "The email sent by the connector includes the top 10 headlines."

    - description: "Connector sends an email including the current weather for San Jose, CA"
      preconditions: "SendGrid is configured and weather data for San Jose, CA is available."
      postconditions: "The email sent by the connector includes the current weather for San Jose, CA."

    - description: "Connector executes without additional user intervention"
      preconditions: "All necessary packages are pre-installed."
      postconditions: "The connector code runs and executes correctly (e.g. passes a health check)."

  tests:
    - description: "Send Email"
      preconditions: "SendGrid configuration is stored in state."
      postconditions: "Connector sends an email to recipient email."
      function_to_run: !python/function |
        def test_send_email_to_recipient(zerg_state=None):
          """Test that the SendGrid connector sends an email to idanbeck@gmail.com."""
          print("Sending email using sendgrid api")
          
          assert zerg_state, "this test requires valid zerg_state"

          # Ensure required keys exist; use dict.get() for safe retrieval.
          sendgrid_api_key = zerg_state.get("sendgrid_api_key").get("value")
          sender_email = zerg_state.get("sender email").get("value")
          recipient_email = zerg_state.get("recipient email").get("value")

          # Basic assertions to verify all necessary fields are present.
          assert sendgrid_api_key, "Missing sendgrid_api_key in agent state"
          assert sender_email, "Missing sender email in agent state"
          assert recipient_email, "Missing recipient email in agent state"

          # Attempt to import the SendGridConnector object.
          from connector import SendGridConnector

          connector = SendGridConnector(
              sendgrid_api_key=sendgrid_api_key,
              sender_email=sender_email
          )

          result = connector.send_email(
              recipient=recipient_email,
              subject="Test Email",
              body="This is a test email."
          )

          assert result is True, "Email not sent successfully"

          return True

    - description: "Send Email Including Top 10 Google News Headlines"
      preconditions: "SendGrid is configured and Google News headlines are available."
      postconditions: "The email sent includes the top 10 headlines."
      function_to_run: !python/function |
        def test_send_email_with_headlines(zerg_state=None):
            """Test that the SendGrid connector sends an email with the top 10 Google News headlines."""
            print("Sending email with top 10 Google News headlines")

            assert zerg_state, "Zerg state required and not provided correctly to unit test"

            sendgrid_api_key = zerg_state.get("sendgrid_api_key").get("value")
            sender_email = zerg_state.get("sender email").get("value")
            recipient_email = zerg_state.get("recipient email").get("value")

            assert sendgrid_api_key, "Missing sendgrid_api_key in agent state"
            assert sender_email, "Missing sender email in agent state"
            assert recipient_email, "Missing recipient email in agent state"

            from connector import SendGridConnector

            connector = SendGridConnector(
              sendgrid_api_key=sendgrid_api_key,
              sender_email=sender_email
            )  

            headlines = connector.get_top_google_headlines(count=10)

            email_body = "Top 10 Headlines:\n" + "\n".join(f"{i+1}. {h}" for i, h in enumerate(headlines))
            result = connector.send_email(
                recipient=recipient_email,
                subject="Top Headlines",
                body=email_body
            )
            assert result is True, "Email with headlines not sent successfully"

            return True

    - description: "Send Email Including Current Weather for San Jose, CA"
      preconditions: "SendGrid is configured and weather data for San Jose, CA is available."
      postconditions: "The email sent includes the current weather for San Jose, CA."
      function_to_run: !python/function |
        def test_send_email_with_weather(zerg_state=None):
            """Test that the SendGrid connector sends an email with current weather for San Jose, CA."""
            print("Sending email with current weather for San Jose, CA")

            assert zerg_state, "Zerg state required and not provided correctly to unit test"

            sendgrid_api_key = zerg_state.get("sendgrid_api_key").get("value")
            sender_email = zerg_state.get("sender email").get("value")
            recipient_email = zerg_state.get("recipient email").get("value")
            location = zerg_state.get("location").get("value")

            assert sendgrid_api_key, "Missing sendgrid_api_key in agent state"
            assert sender_email, "Missing sender email in agent state"
            assert recipient_email, "Missing recipient email in agent state"
            assert location, "Missing location in agent state"

            from connector import SendGridConnector

            connector = SendGridConnector(
              sendgrid_api_key=sendgrid_api_key,
              sender_email=sender_email
            )  

            weather = connector.get_current_weather(location=location)
            email_body = f"Current weather in San Jose, CA:\n{weather}"

            result = connector.send_email(
                recipient=recipient_email,
                subject=f"Current Weather in {location}",
                body=email_body
            )
            assert result is True, "Email with weather data not sent successfully"

            return True

  references: []
  
  configs:
    - name: "sendgrid_api_key"
      description: "SendGrid API key to be used for sending emails"
      value: !env/var 
    - name: "sender email"
      description: "Sender email address for sending emails with SendGrid"
      value: "idan@epochml.com"
    - name: "recipient email"
      description: "Recipient email for testing email sending"
      value: "idanbeck@gmail.com"
    - name: "location"
      description: "To be used to retrieve weather at a particular location"
      value: "San Jose, CA"
# !# SendGrid Email Service


# TODO: React app of some kind once we exceed python only

# Multi-file Python Project Benchmark: Foobar
#
# Tests code organization, module imports, and cross-file dependencies.
# This benchmark validates the AI's ability to work with existing workspace
# files and create proper Python project structure. References foobar.py
# from the workspace which contains sample classes Foo, Bar, and Baz.
- name: "foobar"
  category: "Multi-file Python Project"
  description: |
    Create a simple multi-file Python project that references files in the workspace.
    The workspace should contain a file (e.g., foobar.py) with three classes (e.g., Foo, Bar, and Baz).
    The project code should import that file, instantiate the classes, and call their methods to verify proper functionality.

  specs:
    - description: "Project correctly imports workspace.foobar"
      preconditions: "The workspace file 'foobar.py' exists defining classes Foo, Bar, and Baz"
      postconditions: "The implementation successfully imports the file and accesses its classes"

    - description: "Classes are instantiated and methods return expected outputs"
      preconditions: "The workspace file is imported"
      postconditions: "Instances of Foo, Bar, and Baz are created and calling their methods returns the expected strings"

    - description: "Implementation executes without errors"
      preconditions: "All files are present."
      postconditions: "The code runs to completion without errors or user intervention"
  
  tests:
    - description: "Import Workspace File and Instantiate Classes"
      preconditions: "Workspace file 'foobar.py' exists containing classes Foo, Bar, and Baz."
      postconditions: "The project imports the workspace file and instantiates each class."
      function_to_run: !python/function |
        def test_import_and_instantiate(zerg_state=None):
            """Test importing the workspace file and instantiating classes."""
            print("Testing workspace file import and class instantiation")

            from main import create_foo_bar_baz

            foo, bar, baz = create_foo_bar_baz()

            assert foo is not None, "Failed to instantiate Foo"
            assert bar is not None, "Failed to instantiate Bar"
            assert baz is not None, "Failed to instantiate Baz"

            return True

    - description: "Call Methods on Workspace Classes"
      preconditions: "Classes are successfully instantiated."
      postconditions: "Calling methods on Foo, Bar, and Baz returns expected strings."
      function_to_run: !python/function |
        def test_call_class_methods(zerg_state=None):
            """Test that methods on workspace classes are callable and return expected outputs."""
            print("Testing calling methods on workspace classes")

            from main import create_foo_bar_baz

            foo, bar, baz = create_foo_bar_baz()

            foo_result = foo.do_something()   # Expected to return a string containing "Foo"
            bar_result = bar.do_something()     # Expected to return a string containing "Bar"
            baz_result = baz.do_something()     # Expected to return a string containing "Baz"

            assert isinstance(foo_result, str) and "Foo" in foo_result, "Unexpected result from Foo"
            assert isinstance(bar_result, str) and "Bar" in bar_result, "Unexpected result from Bar"
            assert isinstance(baz_result, str) and "Baz" in baz_result, "Unexpected result from Baz"

            return True

  references: 
    - description: "foobar.py contains the object code as pertinent to this benchmark"
      file_path: "domains/core/foobar.py"
      workspace_path: "foobar.py"
      environment_path: "foobar.py"
      format: "python"
      required: true
      read_only: true

  configs: []
# !Multi-file Python Project: Foobar

# Twilio SMS Service Integration Benchmark
#
# Tests SMS service integration, authentication, and message composition.
# Validates the AI's ability to integrate with Twilio's REST API, manage
# credentials securely, and compose SMS messages with dynamic content.
- name: "twilio"
  category: "SMS Service"
  description: |
    Create a connector that uses the Twilio API to send SMS messages.
    The connector must store the Twilio Account SID, Auth Token, and sender phone number in state,
    and provide functionality to send SMS messages.
    The connector should be able to:
      - send an SMS to a designated recipient,
      - send an SMS that includes the top 10 Google News headlines,
      - send an SMS that includes the current weather for a given location.
    The connector code should also run without errors or user intervention.

  specs:
    - description: "Connector stores Twilio credentials and sender phone number"
      preconditions: "No Twilio configuration present in state."
      postconditions: "The connector successfully saves the Twilio Account SID, Auth Token, and sender phone number to state."
    - description: "Connector sends an SMS to the designated recipient"
      preconditions: "Twilio is configured with valid credentials and a sender phone number."
      postconditions: "The connector sends an SMS to the recipient phone number."
    - description: "Connector sends an SMS including the top 10 Google News headlines"
      preconditions: "Twilio is configured and the connector can fetch Google News headlines."
      postconditions: "The SMS sent by the connector includes exactly the top 10 headlines."
    - description: "Connector sends an SMS including current weather for a given location"
      preconditions: "Twilio is configured and weather data for the location is available."
      postconditions: "The SMS sent by the connector includes the current weather data for the specified location."
    - description: "Connector executes without additional user intervention"
      preconditions: "All necessary packages are pre-installed."
      postconditions: "The connector code runs and passes a basic health check."

  tests:
    - description: "Store Twilio Configuration to State"
      preconditions: "No Twilio configuration is set in state."
      postconditions: "State contains the Twilio Account SID, Auth Token, and sender phone number."
      function_to_run: !python/function |
        def test_store_twilio_config(zerg_state=None):
            """Test storing Twilio credentials and sender phone to state."""
            print("Storing Twilio configuration to state")

            assert zerg_state, "Zerg state required and not provided correctly to unit test"

            twilio_account_sid = zerg_state.get("twilio_account_sid").get("value")
            twilio_auth_token = zerg_state.get("twilio_auth_token").get("value")
            sender_phone = zerg_state.get("twilio_sender_phone").get("value")
            recipient_phone = zerg_state.get("recipient_phone").get("value")

            assert twilio_account_sid, "Account SID not stored"
            assert twilio_auth_token, "Auth Token not stored"
            assert sender_phone, "Sender phone not stored"
            assert recipient_phone, "Recipient phone not stored"

            return True

    - description: "Send SMS to Recipient"
      preconditions: "Twilio configuration is stored in state."
      postconditions: "Connector sends an SMS to the designated recipient phone number."
      function_to_run: !python/function |
        def test_send_sms_to_recipient(zerg_state=None):
            """Test that the Twilio connector sends an SMS to the recipient."""
            print("Sending SMS to recipient")

            # Retrieve configuration from state (assumed to be available)
            
            assert zerg_state, "Zerg state required and not provided correctly to unit test"

            twilio_account_sid = zerg_state.get("twilio_account_sid").get("value")
            twilio_auth_token = zerg_state.get("twilio_auth_token").get("value")
            sender_phone = zerg_state.get("twilio_sender_phone").get("value")
            recipient_phone = zerg_state.get("recipient_phone").get("value")

            assert twilio_account_sid, "Account SID not stored"
            assert twilio_auth_token, "Auth Token not stored"
            assert sender_phone, "Sender phone not stored"
            assert recipient_phone, "Recipient phone not stored"

            connector = TwilioConnector(
                account_sid=twilio_account_sid,
                auth_token=twilio_auth_token,
                sender_phone=sender_phone
            )

            result = connector.send_sms(
                recipient=recipient_phone,
                message="Test SMS"
            )

            assert result is True, "SMS not sent successfully"
            
            return True

    - description: "Send SMS Including Top 10 Headlines"
      preconditions: "Twilio is configured and Google News headlines are available."
      postconditions: "The SMS sent includes exactly the top 10 headlines."
      function_to_run: !python/function |
        def test_send_sms_with_headlines(zerg_state=None):
            """Test that the Twilio connector sends an SMS with top 10 Google News headlines."""
            print("Sending SMS with top 10 headlines")

            assert zerg_state, "Zerg state required and not provided correctly to unit test"

            twilio_account_sid = zerg_state.get("twilio_account_sid").get("value")
            twilio_auth_token = zerg_state.get("twilio_auth_token").get("value")
            sender_phone = zerg_state.get("twilio_sender_phone").get("value")
            recipient_phone = zerg_state.get("recipient_phone").get("value")

            assert twilio_account_sid, "Account SID not stored"
            assert twilio_auth_token, "Auth Token not stored"
            assert sender_phone, "Sender phone not stored"
            assert recipient_phone, "Recipient phone not stored"
                
            connector = TwilioConnector(
                account_sid=twilio_account_sid,
                auth_token=twilio_auth_token,
                sender_phone=sender_phone
            )

            headlines = connector.get_top_google_headlines(count=10)
            message = "Top 10 Headlines:\n" + "\n".join(f"{i+1}. {h}" for i, h in enumerate(headlines))

            result = connector.send_sms(
                recipient=recipient_phone,
                message=message
            )

            assert result is True, "SMS with headlines not sent successfully"
            
            return True

    - description: "Send SMS Including Current Weather"
      preconditions: "Twilio is configured and weather data for the location is available."
      postconditions: "The SMS sent includes the current weather for the specified location."
      function_to_run: !python/function |
        def test_send_sms_with_weather(zerg_state=None):
            """Test that the Twilio connector sends an SMS with current weather data."""
            print("Sending SMS with current weather")
            
            assert zerg_state, "Zerg state required and not provided correctly to unit test"

            twilio_account_sid = zerg_state.get("twilio_account_sid").get("value")
            twilio_auth_token = zerg_state.get("twilio_auth_token").get("value")
            sender_phone = zerg_state.get("twilio_sender_phone").get("value")
            recipient_phone = zerg_state.get("recipient_phone").get("value")
            location = zerg_state.get("location").get("value")

            assert twilio_account_sid, "Account SID not stored"
            assert twilio_auth_token, "Auth Token not stored"
            assert sender_phone, "Sender phone not stored"
            assert recipient_phone, "Recipient phone not stored"
            assert location, "Location not stored"
                
            connector = TwilioConnector(
                account_sid=twilio_account_sid,
                auth_token=twilio_auth_token,
                sender_phone=sender_phone
            )
            
            weather = connector.get_current_weather(location=location)
            message = f"Current weather in {location}:\n{weather}"
            result = connector.send_sms(
                recipient=recipient_phone,
                message=message
            )

            assert result is True, "SMS with weather data not sent successfully"
            
            return True

    - description: "Connector Code Execution Test"
      preconditions: "All necessary packages are installed and configuration is set."
      postconditions: "The connector code runs correctly without errors or user intervention."
      function_to_run: !python/function |
        def test_twilio_execution(zerg_state=None):
            """Test that the Twilio connector code executes without error."""
            print("Executing Twilio connector code")
            
            connector = TwilioConnector()
            result = connector.health_check()
            
            assert result is True, "Connector health check failed"

            return True

  references: []
  configs:
    - name: "twilio_account_sid"
      description: "Twilio Account SID for sending SMS"
      value: !env/var
    - name: "twilio_auth_token"
      description: "Twilio Auth Token for authentication"
      value: !env/var
    - name: "twilio_sender_phone"
      description: "Sender phone number (in E.164 format, e.g., +12345678901)"
      value: !env/var
    - name: "recipient_phone"
      description: "Recipient phone number for testing SMS sending"
      value: "+16073514585"
    - name: "location"
      description: "Location for retrieving weather data (e.g., 'San Jose, CA')"
      value: "San Jose, CA"
# !Twilio Email Connector

# SysAid ITSM Service Integration Benchmark
#
# Tests IT Service Management system integration including service request
# creation, ticket management, and asset tracking. Validates the AI's ability
# to work with enterprise ITSM platforms and handle complex API workflows.
- name: "sysaid"
  category: "ITSM Service"
  description: |
    Create a connector that uses the SysAid API to manage service requests, incidents, and assets. 
    The connector must save the SysAid URL, account ID, username, and password, and provide functionality
    to create, update, and retrieve service requests, incidents, and asset information.

  specs:
    - description: "Connector stores SysAid authentication credentials"
      preconditions: "The system state has not yet been configured for SysAid."
      postconditions: "The connector successfully saves the SysAid URL, account ID, username, and password to state."

    - description: "Connector creates a new service request in SysAid"
      preconditions: "SysAid is configured with valid credentials."
      postconditions: "The connector creates a new service request in SysAid."

    - description: "Connector retrieves service requests from SysAid"
      preconditions: "SysAid is configured and service requests exist in the system."
      postconditions: "The connector retrieves and displays a list of service requests from SysAid."

    - description: "Connector updates an existing service request in SysAid"
      preconditions: "SysAid is configured and a specific service request exists to be updated."
      postconditions: "The connector updates the specified service request with new information."

    - description: "Connector executes without additional user intervention"
      preconditions: "All necessary packages are pre-installed."
      postconditions: "The connector code runs and executes correctly (e.g. passes a health check)."

  tests:
    - description: "Create SysAid Service Request"
      preconditions: "SysAid configuration is stored in state."
      postconditions: "Connector creates a new service request in SysAid."
      function_to_run: !python/function |
        def test_create_sysaid_service_request(zerg_state=None):
          """Test that the SysAid connector creates a new service request."""
          print("Creating new service request using SysAid API")
          
          assert zerg_state, "this test requires valid zerg_state"

          # Ensure required keys exist; use dict.get() for safe retrieval.
          sysaid_url = zerg_state.get("sysaid_url").get("value")
          sysaid_account_id = zerg_state.get("sysaid_account_id").get("value")
          sysaid_username = zerg_state.get("sysaid_username").get("value")
          sysaid_password = zerg_state.get("sysaid_password").get("value")

          # Basic assertions to verify all necessary fields are present.
          assert sysaid_url, "Missing sysaid_url in agent state"
          assert sysaid_account_id, "Missing sysaid_account_id in agent state"
          assert sysaid_username, "Missing sysaid_username in agent state"
          assert sysaid_password, "Missing sysaid_password in agent state"

          # Attempt to import the SysAidConnector object.
          from connector import SysAidConnector

          connector = SysAidConnector(
              sysaid_url=sysaid_url,
              sysaid_account_id=sysaid_account_id,
              sysaid_username=sysaid_username,
              sysaid_password=sysaid_password
          )

          # Get a valid category
          categories = connector.get_categories(limit=1)
          assert categories and len(categories) > 0, "No categories found in SysAid"
          category_id = categories[0]["id"]

          # Get a valid user as the requester
          users = connector.get_users(limit=1)
          assert users and len(users) > 0, "No users found in SysAid"
          user_id = users[0]["id"]

          sr_data = {
              "title": "Test Service Request",
              "description": "This is a test service request created by the connector.",
              "priority": "3",
              "category": category_id,
              "request_user": user_id,
              "status": "1"  # New/Open status
          }

          sr_id = connector.create_service_request(
              sr_data=sr_data
          )

          assert sr_id, "Service request was not created successfully"

          return True

    - description: "Retrieve SysAid Service Requests"
      preconditions: "SysAid is configured and service requests exist in the system."
      postconditions: "The connector retrieves a list of service requests from SysAid."
      function_to_run: !python/function |
        def test_retrieve_sysaid_service_requests(zerg_state=None):
            """Test that the SysAid connector retrieves service requests."""
            print("Retrieving service requests from SysAid")

            assert zerg_state, "Zerg state required and not provided correctly to unit test"

            sysaid_url = zerg_state.get("sysaid_url").get("value")
            sysaid_account_id = zerg_state.get("sysaid_account_id").get("value")
            sysaid_username = zerg_state.get("sysaid_username").get("value")
            sysaid_password = zerg_state.get("sysaid_password").get("value")

            assert sysaid_url, "Missing sysaid_url in agent state"
            assert sysaid_account_id, "Missing sysaid_account_id in agent state"
            assert sysaid_username, "Missing sysaid_username in agent state"
            assert sysaid_password, "Missing sysaid_password in agent state"

            from connector import SysAidConnector

            connector = SysAidConnector(
                sysaid_url=sysaid_url,
                sysaid_account_id=sysaid_account_id,
                sysaid_username=sysaid_username,
                sysaid_password=sysaid_password
            )  

            # Get active service requests
            service_requests = connector.get_service_requests(
                status="1",  # Open/Active status
                limit=10
            )

            assert service_requests and len(service_requests) > 0, "No active service requests retrieved from SysAid"

            return True

    - description: "Update SysAid Service Request"
      preconditions: "SysAid is configured and a specific service request exists to be updated."
      postconditions: "The connector updates the specified service request with new information."
      function_to_run: !python/function |
        def test_update_sysaid_service_request(zerg_state=None):
            """Test that the SysAid connector updates an existing service request."""
            print("Updating existing SysAid service request")

            assert zerg_state, "Zerg state required and not provided correctly to unit test"

            sysaid_url = zerg_state.get("sysaid_url").get("value")
            sysaid_account_id = zerg_state.get("sysaid_account_id").get("value")
            sysaid_username = zerg_state.get("sysaid_username").get("value")
            sysaid_password = zerg_state.get("sysaid_password").get("value")

            assert sysaid_url, "Missing sysaid_url in agent state"
            assert sysaid_account_id, "Missing sysaid_account_id in agent state"
            assert sysaid_username, "Missing sysaid_username in agent state"
            assert sysaid_password, "Missing sysaid_password in agent state"

            from connector import SysAidConnector

            connector = SysAidConnector(
                sysaid_url=sysaid_url,
                sysaid_account_id=sysaid_account_id,
                sysaid_username=sysaid_username,
                sysaid_password=sysaid_password
            )  

            # Get the first active service request
            service_requests = connector.get_service_requests(status="1", limit=1)  # Open/Active status
            assert service_requests and len(service_requests) > 0, "No active service requests found in SysAid"
            sr_id = service_requests[0]["id"]

            update_data = {
                "title": "Updated Test Service Request",
                "description": "This service request has been updated by the connector.",
                "priority": "2",
                "notes": "Updated via connector automation test."
            }

            result = connector.update_service_request(
                sr_id=sr_id,
                update_data=update_data
            )

            assert result is True, "Service request was not updated successfully"

            return True

    - description: "Retrieve SysAid Assets"
      preconditions: "SysAid is configured and assets exist in the system."
      postconditions: "The connector retrieves asset information from SysAid."
      function_to_run: !python/function |
        def test_retrieve_sysaid_assets(zerg_state=None):
            """Test that the SysAid connector retrieves asset information."""
            print("Retrieving assets from SysAid")
            
            assert zerg_state, "this test requires valid zerg_state"

            # Ensure required keys exist; use dict.get() for safe retrieval.
            sysaid_url = zerg_state.get("sysaid_url").get("value")
            sysaid_account_id = zerg_state.get("sysaid_account_id").get("value")
            sysaid_username = zerg_state.get("sysaid_username").get("value")
            sysaid_password = zerg_state.get("sysaid_password").get("value")

            # Basic assertions to verify all necessary fields are present.
            assert sysaid_url, "Missing sysaid_url in agent state"
            assert sysaid_account_id, "Missing sysaid_account_id in agent state"
            assert sysaid_username, "Missing sysaid_username in agent state"
            assert sysaid_password, "Missing sysaid_password in agent state"

            # Attempt to import the SysAidConnector object.
            from connector import SysAidConnector

            connector = SysAidConnector(
                sysaid_url=sysaid_url,
                sysaid_account_id=sysaid_account_id,
                sysaid_username=sysaid_username,
                sysaid_password=sysaid_password
            )

            # Get asset information
            assets = connector.get_assets(limit=10)
            
            assert assets and len(assets) > 0, "No assets retrieved from SysAid"

            return True

  references: []
  
  configs:
    - name: "sysaid_url"
      description: "SysAid instance URL (e.g. 'company.sysaidit.com')"
      value: !env/var
    - name: "sysaid_account_id"
      description: "SysAid account ID for authentication"
      value: !env/var
    - name: "sysaid_username"
      description: "SysAid username for authentication"
      value: !env/var
    - name: "sysaid_password"
      description: "SysAid password for authentication"
      value: !env/var
# !# SysAid ITSM Service